
## Java란 ?

[ 개념 ]
- 프로그래밍에 사용될 데이터의 상태와 행위를 객체로 만들어 객체 간 상호작용을 통해 비즈니스 로직을 구성하는 OOP 언어이다.
- 기본 자료형을 제외한 모든 요소가 객체로 표현됨

[ 특징 ]
- JVM 위에서 실행되어 운영체제에 독립적
- 컴파일링 언어로 한 번에 컴파일 됨
- 컴파일시 데이터 타입이 결정되는 정적 타입 언어

[ 장점 ]
- 운영체제 독립적 : 플랫폼에 종속적이지 않음
- 동적 로딩 지원 : 애플리케이션 실행 시 모든 객체 생성이 아닌, 각 객체는 필요한 시점에 동적 로딩 및 생성됨
- 자동 메모리 관리 : GC를 통해 참조되지 않는 객체는 Heap영역에서 GC에 의해 자동적으로 관리됨

[ 단점 ]
- 한 번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고 JVM에 의해 기계어로 번역되고 실행되는 과정을 거치기 때문에 비교적 느림
- 다중 상속이나 타입에 엄격함

---
## Java의 컴파일 과정

[ 과정 ]
- 개발자가 Java 파일 생성
- Build 수행
- Java Compiler의 javac 명령어를 통해 바이트코드(.class)를 생성
- Class Loader를 통해 JVM 메모리 내로 로드
- Execution Engine을 통해 기계어로 해석(각 운영체제에 맞는 기계어로)

---
## 자바의 메모리 영역

- 메소드(Method) 영역
	- 전역변수, static 변수 저장 / 프로그램 시작부터 종료까지 메모리에 존재
	- JVM이 동작해서 클래스 로딩될 때 생성
- 스택(Stack) 영역
	- 지역변수, 매개변수 등 저장 (LIFO)
	- 메소드 호출시 할당되며, 종료될 때 해제됨
- 힙(Heap) 영역
	- new 키워드로 생성되는 객체, 배열 등 저장 / GC에 의해 메모리 관리 이루어짐
	- 런타임시 할당됨

---
## 오버라이딩(Overriding) & 오버로딩(Overloading)

- 오버라이딩은 상위 클래스의 메소드를 하위 클래스에서 재정의 하는 것
- 오버로딩은 매개변수의 개수나 타입을 다르게 하여, 같은 이름의 메소드를 여러 개 정의하는 것

---
## 객체지향 프로그래밍(OOP)란 ?

[ 개념 ]
- 실생활에 쓰이는 모든 것이 곧 객체임
- 이런 객체를 파악하고 상태와 행위를 가진 객체를 만들어 객체 간 상호작용을 통해 비즈니스 로직을 적용하여 프로그래밍 하는 것을 말함

[ 특징 ]
- 캡슐화 
	- 연관성 높은 속성 & 기능들을 묶어 외부로부터 데이터를 보호 (ex. 객체 내의 필드 private)
	- 정보 은닉을 통해 데이터를 보호함 -> 결합도 낮추고, 응집도 높임
	- 객체 내부가 감춰지기 때문에 동작에 대한 이해도가 떨어질 수 있음
- 상속
	- 기존 클래스를 재활용하여 새로운 클래스를 작성하는 것
	- 반복적인 코드를 최소화 하여 재사용성을 높임
	- 하지만, 강한 결합을 강제하고 접근자에 대한 제약이 걸림
- 추상화
	- 불필요한 세부사항은 제거하고, 공통적인 부분을 추출하여 표현하는 것
	- 유연성과, 변경성 증가
	- 세부사항을 제거하기 때문에 이해가 어렵고, 공통적인 부분 때문에 수정이 번거로움
- 다형성 
	- 어떤 객체의 속성, 기능을 상황에 따라 여러가지 형태를 가질 수 있는 성질 (ex. 오버라이딩, 오버로딩)
	- 객체 형식을 추상화하기 때문에 유연성 증가, 재사용성 증가
	- 동일한 이름의 메소드를 사용하는 경우 복잡성이 증가함, 런타임 시 결정하기 때문에 오버헤드 발생

[ 설계 원칙 ] 
- SRP - 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 함
- OCP - 개방 폐쇄 원칙 : 확장에는 열려 있고, 수정에는 닫혀있어야 함
- LSP - 리스코프 치환 원칙 : 하위 타입은 상위 타입을 대체할 수 있어야 함
- ISP - 인터페이스 분리 원칙 : 인터페이스는 최대한 상세히 나누자 (필요한 것에만 의존하도록)
- DIP - 의존관계 역전 원칙 : 구체 클래스 보단 추상 클래스에 의존하자 (변할 가능성이 적기 때문에)

---
## Wrapper Class와 Boxing & UnBoxing 이란 ?

- 기본 자료형(Primitive data Type)에 대한 객체 표현을 Wrapper class라고 함
- 기본 자료형 -> Wrapper class로 변환 (Boxing)
- Wrapper class -> 기본 자료형으로 변환 (UnBoxing)

---
## Synchronized ? ✅

- 여러 개의 쓰레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 쓰레드를 제외하고 나머지 쓰레드들은 접근할 수 없게 막는 개념
- 데이터의 Thread-safe를 위해 자바에서 Synchronized 키워드를 제공함
- 변수와, 메소드에 사용하여 동기화 할 수 있음 

---
## new String() 과 리터럴("")의 차이점

- new String()은 new 키워드로 새로운 객체를 생성하여 Heap 메모리 영역에 저장
- "" 는 Heap안에 있는 String Constant Pool 영역에 저장

---
## String, StringBuffer, StringBuilder 차이점

- String은 불변의 속성을 가지며, StringBuffer와 StringBuilder는 가변의 속성을 가짐
- StringBuffer는 동기화를 지원하여 멀티 쓰레드 환경에서 Thread-safe함
- StringBuilder는 동기화를 지원하지 않아 싱글 쓰레드 환경에서 주로 사용함 (성능 제일 좋음)

---
## String 객체가 불변인 이유

- 캐싱 기능에 의핸 메모리 절약, 속도향상
	- 참조하려는 문자열이 String Pool에 존재하는 경우 새로 생성하지 않고 Pool에 있는 객체를 사용하기 때문에 특정 문자열 값을 재사용하는 빈도가 높을수록 성능 향상 기대 
- Thread-safe 
	- 불변이기 때문에 여러 쓰레드에서 동시 접근해도 안전함

---
## 접근 제한자(Access Modifier)란 ?

- 변수 또는 메소드의 접근 범위를 설정해주기 위해 사용하는 것
- Public - 접근 제한 없음 (같은 프로젝트 내 어디든 OK)
- Protected - 해당 패키지 내, 다른 패키지에서 상속 받은 자손 클래스 접근 가능
- (default) - 해당 패키지 내에서 접근 가능
- Private - 해당 클래스에서만 접근 가능

---
## Static 이란 ?

- static 키워드는 고정된이란 의미를 가지는데, 프로그램 실행 시 메모리에 고정적으로 할당되기 때문임
- non-static은 객체마다 메모리 공간이 별도로 존재하며 객체와 생명주기가 동일함 (인스턴스 변수라고 함)
- 클래스가 로딩될 때 생성되며 바로 사용할 수 있음 즉, 인스턴스 객체 없이 바로 사용 OK
- 모든 객체가 메모리 공유하고 GC 관리 영역 밖에 있어서 프로그램 종료될 때 까지 메모리 값이 존재함
- 사용하는 이유
	- 자주 변하지 않거나 공통으로 사용되는 값을 매번 메모리에 로딩하거나, 읽어들이지 않게함
	- 인스턴스 생성 없이 바로 사용 가능하기 때문에 공통으로 사용되는 데이터 관리시 이용함

---
## 리플렉션(Reflection)이란 ? ✅

- 구체적인 클래스 타입을 몰라도 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API
- 언제 사용하느냐 ?
	- 코드 작성 시점에는 어떤 타입 클래스 사용할 지 모르지만 런타임 시점에 가져와야 하는 경우
- 장점 
	- 런타임 시점에 사용할 Instance를 선택 (유연)
- 단점
	- 컴파일이 아닌 런타임 시점에 오류 잡음
	- 접근 제어자로 캡슐화 된 필드나 메서드에 접근 -> 캡슐화 깨뜨림

---
## Error / Exception

- Error는 실행 중 일어날 수 있는 치명적 오류로 컴파일 시점에 체크가 불가능하며 프로그램이 비정상 종료됨
- Exception은 경미한 오류로, 예외 처리를 통해 프로그램의 비정상 종료를 막을 수 있음

---
## CheckedException / UnCheckedException ✅

- CheckedException
	- 컴파일 시점에 체크
	- 반드시 예외처리를 해야함 (강제)
	- throws -> 의존성 문제 야기, 다른 부분에서도 Exception 관련 라이브러리 의존하게 됨
- UnCheckedException
	- 런타임 시점에 체크 
	- 따로 예외처리 하지 않아도 됨 (옵션)

---
## 컬렉션 프레임워크 ? ✅

- 다수의 데이터를 쉽고 효과적으로 관리할 수 있는 방법을 제공하는 클래스의 집합
- 자바에서는 List, Map, Set 인터페이스를 기준으로 Stack, Queue도 존재함
- List
	- 순서 O
	- 데이터 중복 허용 O
- Set
	- 순서 X
	- 데이터 중복 허용 X
- Map
	- 순서 X
	- <key, value> 한 쌍의 형태로 이루어짐
	- 키를 기준으로 중복 허용 X, 값을 기준으로는 허용
	- LinkedHashMap 사용하면 순서가 보장됨

---
## equals와 == 

- == (동일성)
	- 두 객체가 같은 메모리 공간을 가리키는지 확인하는 참조 비교 (주소값 비교)
- equals (동등성)
	- 두 객체의 내부 값이 같은지 비교
	- 기본 타입은 적용 불가하며 override해서 원하는 방식으로 수정 가능


---
## Equals(), HashCode() 같이 사용하는 이유

- equals()만 잘 정의해도 모든 객체의 동등성이 보장될 것 같지만, Hash 값을 사용하는 Hash Collection 자료구조 때문에 그렇지 않은 경우가 발생함
- Hash Collections는 hashCode() 리턴값 -> equals() 리턴값 -> 동등객체로 판단함

---
## 제네릭(Generic)이란 ? 

- 제네릭은 데이터 타입을 하나로 지정하지 않고, 사용할 때마다 범용적이고 포괄적으로 지정한다는 의미
- 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 확인할 수 있기 때문에 에러를 사전에 방지할 수 있음
- 사용해 본 경험
	- Response 객체 정의 시 내부 필드에 반환 값을 제네릭을 통해 여러 타입이 올 수 있도록 함

---
## 직렬화(Serialize)란 ?

- 시스템 내부에서 사용되는 객체를 외부 시스템에서도 사용할 수 있도록 바이트(Byte)형태로 변환하는 기술
- ex) 카프카는 메세지를 바이트 배열로 취급하기 때문에 직렬화 과정이 필요함
	- Producer에서 직렬화하여 Kafka Broker로 데이터 전달
	- Consumer는 Kafka Broker로부터 수신한 바이트 배열을 역직렬화함

---
## 추상 클래스 / 인터페이스 ✅

- 추상 클래스
	- 최소 한 개 이상의 추상 메소드를 가진 abstract 클래스
	- 목적 : 관련성 높은 클래스 간의 코드 공유 및 확장을 위한 목적
- 인터페이스
	- default와 static을 제외하고 추상 메소드와 상수만을 포함하여 선언
	- 모든 메소드는 추상 메소드로 그 키워드가 생략되어 있음 
	- 다중 상속 가능
	- 목적 : 관련성 없는 클래스 간의 논리적으로 같은 기능을 자신에 맞게 구현하는 것을 강제하는데 목적
---

## 자바에서 멀티 쓰레드 구현 ✅

[ 멀티 쓰레드 ]
- 멀티 태스킹이란 두 가지 이상의 작업을 동시에 처리하는 것을 의미한다.
- 한 프로세스 내에서 멀티 태스킹을 할 수 있도록 만들어진 프로세스로 예를 들어 메신저 프로세스 같은 경우 채팅 기능을 제공하며 동시에 파일 업로드 기능을 수행함
- 이처럼 한 프로세스에서 멀티 태스킹이 가능한 이유는 멀티 스레드 덕분이다.

[ 구현 방법 ]
- Thread 클래스를 상속하여 쓰레드 생성 및 실행
- Runnable 클래스를 구현하여 쓰레드 생성 및 실행

[ 동시성 문제 ]
- 여러 쓰레드가 동시에 하나의 변수에 접근하여 변수 값이 의도치 않게 변경되는 문제가 발생함
- 이처럼 멀티쓰레드 환경에서 발생할 수 있는 문제를 해결하기 위해 Java에서 동기화(Synchronized) 기능을 제공한다.
- 이를 통해 여러 쓰레드가 공유 변수에 대해 쓰레드 간 접근을 조절할 수 있다.
- 또는 Lock 인터페이스 (=ReentrantLock())을 통해 동기화 기능 구현 가능

[ 많은 수의 쓰레드 관리하기 ]
- 쓰레드 풀 기능을 통해 쓰레드를 생성하고 관리함
- 필요에 따라 동적으로 쓰레드 생성 및 제거를 통해 재사용성을 높임
- ExecutorService 같은 인터페이스를 통해 쓰레드 풀 관리

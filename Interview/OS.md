## 프로세스 & 쓰레드

[ 프로세스 ]
- 프로그램을 실행중인 프로그램을 의미함
- 메모리 영역 (Code, Data, Heap, Stack)을 다른 프로세스와 공유하지 않음
- 최소 1개의 쓰레드(메인 쓰레드)를 가짐

[ 쓰레드 ]
- 프로세스 안에서 실행되는 여러 흐름의 단위
- 메모리 영역 중 Stack 영역을 제외한 나머지 영역을 공유함


> Q. Stack을 쓰레드마다 독립적으로 할당하는 이유 ?
> : 스택은 함수 호출 시 전달되는 인자 등을 저장하기 위해 사용되는 공간으로 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것 즉, 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건임


## 멀티 프로세스 & 멀티 쓰레드

[ 멀티 프로세스 ]
- 하나의 프로그램을 여러 프로세스로 구성해 병렬 작업 수행
- 장점 : 안정성 (메모리 침범 문제를 OS 차원에서 해결해줌)
- 단점 : 각각 독립된 메모리 영역으로 작업량이 많을 수록 오버헤드 발생, Context Switching으로 성능저하

[ 멀티 쓰레드 ]
- 하나의 프로그램을 여러 쓰레드로 구성하여 각 쓰레드가 하나의 작업을 처리하는 것
- 동시성 : 싱글 코어에서 여러 개의 쓰레드가 번갈아 실행하는 것
- 병렬성 : 멀티 코어에서 한 개 이상의 쓰레드를 포함하는 각 코어들을 동시에 실행하는 것
- 장점 : 공유 메모리만큼 시간, 자원 절약 
- 단점 : 하나의 스레드가 데이터 공간 망가뜨리면, 모든 쓰레드 동작 불가능 (임계 영역을 통해 해결)

> 임계 영역
> : 동시접근 자원에 대한 독점을 보장해줘야하는 영역을 의미함


> 멀티 스레드 주의점 !!
: 다수의 스레드가 공유 데이터에 동시 접근하는 경우 상호배제 또는 동기화 기법을 통해 동시성 문제나 데드락에 빠지지 않도록 해야함



## 인터럽트
- 프로그램 실행 중 예기치 않은 상황 발생 → 현재 실행 중인 작업 즉시 중단 및 우선처리가 필요함을 알리는 것
- 외부/내부 인터럽트 
	- 외부 : 전원 이상, 기계 착오 등
	- 내부 : 0으로 나누기, 오버플로우, Exception 등



## PCB & Context Switching

[ PCB ]
- CPU는 각 프로세스들이 누군지 알아야 관리가 가능함
- 각 프로세스들의 특징을 갖고 있는 것이 바로 Meta Data임 (Process ID, State 등)
- 이런 메타 데이터는 프로세스가 생성되면 PCB라는 곳에 저장됨

[ Context Switching ]
- 하나의 프로세스 실행 중 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 하는 상황 발생
- 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장
- 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)를 **교체하는 작업**



## IPC 통신
- 프로세스는 독립적 실행으로 다른 프로세스에게 영향을 받지 않음 → 통신이 까다로움
- 통신을 가능하게 해주는 것이 바로 IPC 통신 (ex. 소켓, 메세지 큐 등)
- IPC 통신에서는 프로세스 간 데이터 동기화 및 보호를 위해 세마포어와 뮤텍스를 사용함


### 세마포어 & 뮤텍스
- 공유된 자원에 여러 프로세스가 동시에 접근하면 문제 발생할 수 있음, 이 때 공유된 자원의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 둬야하는데 이것을 “세마포어”라고 함
- 세마포어 : 멀티프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법
- 뮤텍스 : 임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술 (Lock / Unlock)


### CPU 스케줄링
- CPU 사용을 효율적으로 하기위해 프로세스를 잘 배정해야함
- 선점 스케줄링
    - OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수하는 경우
    - 라운드로빈 : 각 프로세스에 동일한 할당 시간 부여하여 해당 시간동안만 CPU 이용하게 함
- 비선점 스케줄링
    - 어떤 프로세스가 CPU 점유하고 있으면 뺏을 수 없는 방식
    - FCFS : 가장 먼저 요청한 프로세스에게 CPU 할당하는 방식
    - SJF : 실행시간이 가장 짧은 프로세스를 먼저 실행하는 방식

>콘보이 현상 ?
>: 작업 시간 긴 프로세스가 먼저 큐에 도착하여 다른 프로세스의 실행시간이 전부 늦춰지는 현상 (FCFS)



## 데드락

[ 개념 ]
- 두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해 다음 처리를 하지 못하는 상태
- 무한히 다음 자원을 기다리는 상태

[ 발생 조건 ]
- 상호 배제 : 자원은 한 번에 한 프로세스만 사용 가능
- 점유 대기 : 이미 자원을 할당 받고, 다른 프로세스가 점유하는 자원을 또 요구하는 것
- 비선점 : 다른 프로세스에 할당된 자원 강제 빼앗기 불가능
- 순환 대기 : 순환 형태로 자원을 대기해야함

→ 4가지 조건을 모두 만족하는 경우 발생함


[ 예방 & 회피 ]
- 예방 
	- 교착 상태 발생 조건 중 하나를 제거하면서 해결 (= 자원 낭비가 심함)
- 회피
	- 교착 상태 발생 시 피해나가는 방법
	- 은행원 알고리즘 
		- 프로세스가 자원 요구 시, 자원 할당 후에도 안정상태인지 사전 검사를 통해 회피함
		- 안정 상태면 할당, 아니면 다른 프로세스 자원 해지까지 대기
		- 은행은 최소 고객 한명에게 대출할 수 있는 금액을 보유해야 한다에서 파생
		- 안정 상태 : 교착 상태 일으키지 않으면서, 최대 요구량만큼 필요한 자원 할당해줄 수 있는 상태
		- 불안정 상태 : 안전 순서열이 존재하지 않는 상태
		- 단점 : 불안전 상태 방지해야 하므로 자원 이용도가 낮음, 프로세스가 유한시간 내 자원 반납해야함


[ 탐지 & 회복 ]
- 탐지
	- 자원 할당 그래프를 통해 교착 상태 탐지
- 회복
	- 교착 상태 일으킨 프로세스 종료하거나 할당된 자원 해제시켜 회복




## 경쟁 상태 (Race Condition)

[ 개념 ]
- 공유 자원에 대해 여러 프로세스가 동시 접근할 때, 결과에 영향을 줄 수 있는 상태

[ 문제상황과 해결 방안 ]
- 문제 : 커널 작업 수행 중 인터럽트 발생
- 해결 : 커널모드에서 작업 수행 중 인터럽트를 disable 시켜 CPU 제어권을 가져가지 못하게 함



## 페이징과 세그먼테이션

[ 개념 ]
- 다중 프로그래밍 환경에서 여러 프로세스를 수용하기 위해 주기억장치를 동적으로 분할하는 작업이 필요함

[ 관리 ]
- 연속 메모리 관리 : 프로그램 전체가 하나의 커다란 공간에 연속 할당 (단편화 문제가 발생함)
	- 고정분할기법 : 주기억장치가 고정된 파티션으로 분할 (내부 단편화 발생)
	- 동적분할기법 : 파티션들이 동적 생성되며, 자신의 크기와 같은 파티션에 적재 (외부 단편화 발생)

- 불연속 메모리 관리 : 프로그램 일부가 서로 다른 주소 공간에 할당될 수 있는 기법
	- 페이징
		- 프로세스를 일정한 크기의 페이지로 분할하여 적재함 (고정크기)
		- 장점 : 메모리에 저장될 때 연속될 필요 없기 때문에 외부 단편화가 사라짐
		- 단점 : 내부 단편화가 생길 수 있음 (고정크기 이므로)
	- 세그먼테이션
		- 프로세스를 서로 크기가 다른 단위로 분할함 (= 세그먼테이션 , 가변크기)
		- 필요한 메모리 공간 할당하여 내부 단편화는 없지만, 중간에 메모리 해제하면 외부 단편화 발생



## 페이지 교체 알고리즘

[ 개념 ]
- 가상 메모리는 요구 페이징 기법을 통해 필요한 페이지만 메모리에 적재함
- 이 때 필요한 페이지 부재가 발생하고 새로운 페이지를 할당해야하는데 페이지 교체 알고리즘을 통해 할당

[ 종류 ]
- FIFO : 가장 먼저 올라온 페이지
- LRU : 가장 오래전 참조가 이루어진 페이지
- LFU : 참조 횟수가 가장 적은 페이지



## 임계 영역(Critical Section)

[ 개념 ]
- 프로세스 간 공유자원 접근에 있어 문제가 발생하지 않도록 하나의 프로세스만 이용하게끔 보장하는 영역

[ 임계 영역 문제를 해결하기 위한 3가지 조건 ]
- 상호 배제 : 하나의 프로세스가 임계 영역에 들어가면 다른 프로세스는 들어갈 수 없음
- 진행 : 임계 영역에 들어간 프로세스가 없는 상태에서 들어가려는 프로세스가 여러 개면 결정해줘야 함
- 한정 대기 : 다른 프로세스의 기아 방지를 위해, 한 번 들어간 프로세스는 제한을 두어야 함
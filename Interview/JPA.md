
## ORM 이란 ?

[ 개념 ]
- Object-Relation Mapping (객체-관계 매핑)
- 객체는 객체대로, 관계형 DB는 DB 대로 설계
- ORM 프레임워크가 중간에서 매핑해줌
- Hibernate 기반으로 만들어진 ORM 기술 표준

[ 사용 이유 ]
- 개발자가 반복적인 SQL 문 작성 X
- 복잡한 쿼리의 경우 JPQL + SQL Mapper를 혼용하여 사용 가능
- 가독성 좋음
- 수정이 간편해 유지보수, 리팩토링 용이

[ 성능 최적화 기능 ]
- 1차 캐시와 동일성 보장 - 같은 트랜잭션 내 같은 엔티티 반환 (캐시를 통해)
- 트랜잭션 지원하는 쓰기 지연
- 지연 로딩

결국, 객체와 RDBMS를 자동으로 매핑해주는 것을 말함


## 영속성(Persistence)

[ 개념 ]
- 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성


## 영속성 컨텍스트 

[ 개념 ]
- 애플리케이션, DB 사이에서 객체를 보관하는 기능을 수행함
- 엔티티 객체가 영속성 컨텍스트에 들어오면, 매핑 정보를 DB에 반영함
- 엔티티 객체가 영속성 컨텍스트에 들어와 JPA 관리 대상이 되는 시점부터 해당 객체를 '영속 객체'라고 함

[ 생명 주기 - 엔티티 ]
- 비영속 : 영속성 컨텍스트와 관련 없는 상태
- 영속 : 영속성 컨텍스트에 저장된 상태 
- 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 : 영속성 컨텍스트와 데이터베이스에서 삭제된 상태

[ 특징 ]
- 1차 캐시
	- 영속 상태의 엔티티는 모두 1차 캐시에 저장됨, 이후 조회 시 1차 캐시에 있는 데이터 먼저 조회한 후 없는 경우에 DB에 접근하여 다시 1차 캐시에 저장
- 트랜잭션을 지연하는 쓰기 지연
	- 영속성 컨텍스트에 DML이 발생했을 때, DB에 바로 저장하지 않고 커밋될 때 영속성 컨텍스트의 쓰기지연 SQL 저장소에 모아둔 쿼리를 한 번에 저장
	- DB 접근 횟수가 줄어들어 성능면에서 뛰어남
- 변경 감지
	- 1차 캐시에서 스냅샷을 통해 엔티티 변경을 감지하는데, JPA는 1차 캐시에 DB에서 처음 불러온 엔티티의 스냅샷을 가지고 있음
	- 1차 캐시에 저장된 엔티티와 스냅샷 비교 후, 변경 내용이 존재하면 UPDATE SQL문을 쓰기 지연 SQL 저장소에 담아둠


[ 이점 ]
- 중간 계층으로서 버퍼링, 캐싱 등을 활용할 수 있음 



## 벌크성 수정 쿼리
```Java
@Modifying(clearAutomatically = true)
 @Transactional
 @Query("update MemberEntity m set m.age = m.age + 1 where m.age >= :age")
 int bulkAgePlus(@Param("age") int age);
```

- JPA에서 단 건 데이터를 변경(더티 체킹)하는 것이 아닌, 여러 데이터에 변경 쿼리를 날리는 작업을 도움 
- 그러나, 1차 캐시와 관련한 문제가 발생하는데 1차 캐시를 무시하고 바로 Query를 실행해버림
- @Modifying의 clearAutomatically 속성을 통해 데이터 변경 이후 영속성 컨텍스트를 비워주는 작업 수행


## 엔티티 설계 시 주의점

- setter 사용 금지
	- 변경 포인트가 많아서 유지 보수가 어려워짐
- 모든 연관관계는 지연로딩으로 설정
	- 즉시 로딩은 예측이 어려움
	- JPQL 실행 시 N+1 문제가 자주 발생함
	- @XToOne → 관계는 기본이 즉시로딩이므로 수정할 것
- 컬렉션은 필드에서 초기화 
	- 하이버네이트는 엔티티 영속화 할 때, 컬렉션을 감싸서 내장 컬렉션으로 변경하는데 잘못 생성하게 되면 내부 메커니즘에 문제가 발생할 수 있음 
	- 따라서 필드 레벨에서 생성하는 것이 가장 안전하며 코드도 간결함
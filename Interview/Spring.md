
## Spring Framework 란?

[ 개념 ]
- 스프링 프레임워크는 자바 개발을 편리하게 해주는 오픈소스 프레임워크임

[ 특징 ]
- 경량 컨테이너로서 자바 객체를 직접 관리
	- 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 필요한 객체를 얻어올 수 있음
- 제어의 역전(IoC)이라는 기술을 통해 어플리케이션의 느슨한 결합을 도모함
	- 컨트롤의 제어권이 사용자가 아닌 프레임워크에 있음
- 의존성 주입(DI, Dependency Injection)을 지원
	- 각각의 계층이나 서비스들 간 의존성이 존재할 경우 프레임워크가 서로 연결시켜줌
- 관점지향 프로그래밍(AOP, Aspect-Oriented Programming) 지원
	- 트랜잭션, 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능을 분리하여 관리



## @RequestBody, @RequestParam, @ModelAttribute 차이점

[ @RequestBody ]
- 클라이언트가 전송하는 JSON 형태의 HTTP Body 내용을 MessageConverter를 통해 Java 객체로 변환
- reflection을 사용해 할당하기 때문에 변수들의 생성자, Getter, Setter 없어도 할당이 가능함


[ @RequestParam ]
- 1개의 HTTP 요청 파라미터를 받기 위해 사용
- 필수 여부가 True이기 때문에, 반드시 전송되어야 함 
- 필수가 아니라면 required의 값을 false로 설정해야 함


[ @ModelAttribute ]
- HTTP Body 내용과 HTTP 파라미터 값들을 생성자, Getter, Setter를 통해 주입하기 위해 사용함
- 값 주입으로 할당하기 때문에 변수들의 생성자, Getter, Setter 없으면 할당이 불가능함



## Spring Boot와 Spring Framework의 차이점

가장 큰 차이점은 Auto Configuration이 차이이다. Spring은 프로젝트 초기에 다양한 환경설정을 해줘야 하지만, Spring Boot는 설정의 많은 부분을 자동화하여 사용자가 편하게 활용할 수 있도록 돕는다. Spring boot starter dependency만 추가하면 설정은 끝나고, 내장된 톰캣을 제공하여 서버를 바로 실행할 수 있다.



## Spring MVC란 ?

[ 개념 ]
- MVC는 Model, View, Controller의 약자이며, 각 레이어간 기능을 구분하는데 중점을 둔 디자인 패턴
- Model은 데이터 관리 및 비즈니스 로직 처리 (DAO, DTO, Service)
- View는 비즈니스 로직의 처리 결과를 통해 유저 인터페이스 표현되는 구간
- Controller는 사용자 요청을 처리하고 Model과 View를 중개하는 역할

[ 처리 흐름 ]
- 클라이언트가 URL을 통해 요청 전송
- 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청이 어느 컨트롤러에 온 요청인지 찾아냄
- 디스패처 서블릿은 핸들러 어댑터에게 컨트롤러에게 요청할 것을 맡김
- 핸들러 어댑터가 해당 컨트롤러에게 요청을 전달함
- 컨트롤러는 비즈니스 로직을 처리한 후에 반환할 뷰의 이름을 반환함
- 디스패처 서블릿은 뷰 리졸버를 통해 반환할 뷰를 찾음
- 뷰를 반환함



## 제어의 역전(IoC, Inversion Of Control)이란 ?

[ 개념 ]
- 제어의 역전이란 모든 객체에 대한 제어권을 개발자가 아닌 IoC 컨테이너에게 넘기는 것을 의미함
- 스프링에서는 IoC 컨테이너에 객체들을 생성하면 객체끼리 의존성 주입하는 역할을 함
- 컨테이너에 등록한 객체들을 빈이라고 함


> IoC 컨테이너 ?
> - 컨테이너는 보통 객체의 생명주기를 관리함
> - 스프링 프레임워크도 객체를 생성하고 관리하고 책임지고 의존성을 관리해주는 컨테이너가 있음
> - 해당 컨테이너가 바로 IoC 컨테이너 (= 스프링 컨테이너)이다.
>   
> 컨테



## IoC 컨테이너

[ 개념 ]
-  컨테이너는 보통 객체의 생명주기를 관리함
- 스프링 프레임워크도 객체를 생성하고 관리하고 책임지고 의존성을 관리해주는 컨테이너가 있음
- 해당 컨테이너가 바로 IoC 컨테이너 (= 스프링 컨테이너)이다.


[ 스프링 컨테이너의 종류 ]
- 스프링 컨테이너가 관리하는 객체를 빈(Bean)이라고 함
- 빈들을 관리한다는 의미로 컨테이너를 빈 팩토리(Bean Factory)라고 부름
	- BeanFactory의 여러 컨테이너 기능을 추가한 어플리케이션컨텍스트가 있음


[ BeanFactory와 ApplicationContext ]
- BeanFactory
	- 단순히 컨테이너에서 객체 생성, DI 처리하는 기능만 제공
- ApplicationContext
	- BeanFactory의 기능 + 부가적인 기능을 추가로 제공함
	- 국제화, 리스너로 등록된 빈에게 이벤트 발생을 알림 등



## 스프링 빈(Bean) 등록 방법
- @Component 어노테이션
- 설정 클래스를 따로 만들어 @Configuration 어노테이션을 붙이고 해당 클래스 내에서 빈으로 등록할 메소드를 만들어 @Bean 어노테이션을 붙이면 자동으로 해당 타입의 빈 객체가 생성됨



## 의존성 주입(DI, Dependency Injection)이란 ?

[ 개념 ]
- 필요한 객체를 직접 생성하는 것이 아닌 외부로부터 객체를 주입받아 사용하는 것
- 객체 간 결합도를 줄이고 코드의 재사용성을 높일 수 있음

[ 주입 방식 ]
- 생성자 주입
- 필드 주입
- 세터 주입 - setXXX 메서드를 public으로 열어야 함

가장 많이 사용되는 방법은 생성자 주입인데, 
- 순환참조를 방지(컴파일 시점에 오류 발견 가능)
- 불변성(final 로 선언) 가짐
- 테스트(DI 컨테이너 없어도 의존성 주입이 가능)에 용이



## 스프링 빈의 라이프 사이클 

[ 라이프  사이클 ]
스프링 IoC 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백 메소드 호출 → 사용 → 소멸 → 소멸 전 콜백 메소드 호출 → 스프링 종료

[ 크게 3가지 방법으로 빈 생명주기 콜백을 관리함 ]
- 인터페이스(InitializingBean, DisposableBean)
- 설정 정보에 초기화 메소드, 종료 메소드 지정
- @PostConstruct, @PreDestroy 어노테이션 지원



## Spring Filter와 Interceptor 란 ?

[ Filter ]
- 요청과 응답을 거른 뒤 정제하는 역할을 함
- 웹 컨테이너에 의해 관리된다
- 디스패처 서블릿에 요청이 전달되기 전, 후에 url 패턴에 맞는 요청에 대해 부가 작업 처리할 수 있음
- 보안 및 인증/인가 관련 작업
- 모든 요청에 대한 로깅 또는 검사


[ Interceptor ]
- 요청에 대한 작업 전, 후로 가로채어 요청과 응답을 참조하거나 가공하는 역할
- 스프링 컨텍스트에서 동작함
- Controller 호출 전, 후에 인터셉터가 끼어들어 요청과 응답을 참조하거나 가공할 수 있음
- Controller에 넘겨주는 정보(데이터)의 가공



## 관점지향 프로그래밍(AOP)이란 ?

[ 개념 ]
- 핵심 비즈니스 로직에 있는 공통 관심사항을 분리하여 각각 모듈화 하는 것을 의미함
- 인증, 로깅, 트랜잭션 처리에 용이함
- 코드 중복 제거, 재활용성 극대화 
- ex) 로그인 했는지 안했는지 확인 분리하여 수행, 성능 측정을 위해 분리



## Lombok ?

[ 개념 ]
- 롬복은 메소드를 컴파일 하는 과정에 개입하여 추가적인 코드를 만들어낸다.
- 이것을 어노테이션 프로세싱이라고 하며, 자바 컴파일러가 컴파일 단계에서 어노테이션 분석 & 처리하는 기법을 말한다 (Lombok 라이브러리 추가 시, CompileOnly, AnnotationProcessor를 추가하는 이유)



## Servlet

[ 개념 ]
- 클라이언트의 요청을 처리하고 그 결과를 반환하는 기술로 자바 기반 웹 애플리케이션 프로그래밍 기술
- Spring MVC에서 Controller로 이용되며, 사용자의 요청을 받아 처리한 후 결과를 반환
- 간단히 말하면, 자바를 사용해 웹을 만들기 위해 필요한 기술


[ 동작 방식 ]
- 사용자 URL 입력 → HTTP Request가 Servlet Container로 전송
- 요청 받은 Servlet Container는 HttpServletRequest, HttpServletResponse 객체를 생성함
- 사용자가 요청한 URL이 어느 서블릿에 대한 요청인지 찾음
- 해당 서블릿에서 service 메소드 호출 후 doGet() 또는 doPost()를 호출함
- 호출한 메소드에 의해 동적 페이지를 생성한 후 HttpServletResponse 객체에 응답을 보냄
- 응답 끝나면 HttpServletRequest, HttpServletResponse 객체 소멸



## Spring의 싱글톤 패턴

[ 개념 ]
- 스프링 Bean 생성 시 별다른 설정이 없으면 default로 싱글톤이 적용됨
- 스프링 컨테이너를 통해 싱글톤 객체를 생성하고 관리하는데 요청이 들어올 때 마다 생성하는 것이 아니라 이미 만들어진 객체를 공유하기 때문에 효율적인 사용이 가능함
- 장점
	- static 메소드나 private 생성자 등을 사용하지 않아 객체지향적 개발 가능
	- 테스트하기 편리함



## Spring의 프로토 타입 빈이란 ?
- 프로토타입 빈은 싱글톤 빈과는 달리 컨테이너에게 빈을 요청할 때마다 매번 새로운 객체를 생성하여 반환함
- 이렇게 빈의 Scope를 간단하게 관리해줄 수 있는 것이 Spring의 장점임



## @Transactional 동작 원리

- @Transactional을 메소드 또는 클래스에 명시하면 AOP를 통해 Target이 상속하고 있는 인터페이스 또는 Target 객체를 상속한 Proxy 객체가 생성되며, Proxy 객체의 메소드를 호출하면 Target 메소드 전 후로 트랜잭션 처리를 수행함
- 프록시는 클라이언트가 타겟 객체를 호출하는 과정에만 동작함



## @Transactional에 readOnly 속성을 사용하는 이유

- 트랜잭션 안에서 수정/삭제 작업이 아닌 ReadOnly 목적인 경우 사용함
- 영속성 컨텍스트에서 엔티티를 관리할 필요가 없을 때 사용하며, 메모리 성능을 높일 수 있음
- 가독성이 높아짐 (변경 불가능 로직을 표현)

> readOnly 속성이 없는 경우
> - 보통의 트랜잭션은 데이터 조회 결과 엔티티가 영속성 컨텍스트에 관리되어짐
> - 이는 1차 캐싱부터 변경 감지까지 가능하게 함
> - 하지만, 조회 시 스냅샷 인스턴스를 생성해 보관하기 때문에 메모리 사용량이 증가함




## JPA N+1 문제 발생 이유와 해결 방법

[ 개념 ]
- N+1이란 1번의 쿼리를 날렸을 때 의도하지 않은 N번의 쿼리가 추가적으로 실행되는 것을 의미함

[ 해결 방법 ]
- Fetch Join 사용
- N+1 문제가 발생하는 이유는 연관관게를 가진 엔티티를 조회할 때 한 쪽 테이블만 조회하고 연결된 다른 테이블은 따로 조회하기 때문인데 Fetch Join을 사용하여 미리 두 테이블을 Join하고 한 번에 데이터를 모두 가져오기 때문에 방지 가능함
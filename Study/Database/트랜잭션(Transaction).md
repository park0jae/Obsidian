### 개념 
- DBMS에서 데이터를 다루는 논리적인 작업의 단위
- 장애가 일어난 경우 복구하는 작업의 단위
- 여러 작업이 동시에 같은 데이터를 다룰 때는 작업을 서로 분리하는 단위
- **Commit** : 트랜잭션 수행이 완료됨을 알리는 연산
- **Rollback** : 트랜잭션이 행한 모든 연산을 취소하거나 재시작함


### 트랜잭션의 ACID 성질
- 원자성(Atomicity) : 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 함
- 일관성(Consistency) : 트랜잭션 수행하기 전이나 후나 DB는 항상 일관된 상태를 유지해야 함
- 독립성(Isolation) : 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들 수 없음
- 지속성(Durability) : 수행 완료한 트랜잭션은 DB에 영구히 반영되어야 함


### 트랜잭션이 가지는 상태
- 활동(Active)
- 부분 완료(Partially Committed) - 마지막 명령문 실행시킨 직후의 상태
- 완료(Committed)
- 실패(Failed)
- 철회(Aborted) - 롤백 연산을 수행한 상태


### 동시성 제어
- 트랜잭션의 성질 중 고립성은 트랜잭션을 독립적으로 만들어 주었는데, 2개 이상의 트랜잭션이 하나의 값에 접근하는 경우에는 어떻게 될까 ?
- 모두 읽는 경우는 문제가 발생하지 않지만, 하나라도 쓰는 경우가 있는 상황에는 Dirty Read, Pantom Read등의 문제가 발생할 수 있음
- 2개의 트랜잭션이 모두 쓰기를 하는 경우에는 Lost Update, Inconsistency, Cascading Rollback 문제가 발생할 수 있음

[ 갱신 손실 - Lost Update ]
- 하나의 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신 무효화 발생
- 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신(Update)할 때 발생함


[ 모순성 - Inconsistency ]
- 트랜잭션들이 해당 항목 값을 갱신하는 동안 다른 트랜잭션이 두 개의 항목 값 중 어떤 것은 갱신되기 전, 어떤 것은 갱신 이후의 값을 읽게 되어 데이터의 불일치가 발생하는 상황


[ 연쇄 복귀 - Cascading Rollback ]
- 두 트랜잭션이 동일한 데이터에 접근할 때 발생함
- 한 트랜잭션이 데이터 갱신 이후 실패하여 Rollback 연산 수행하는 과정에서 갱신과 Rollback 연산을 실행하는 사이에 해당 데이터를 읽어 사용할 때 발생할 수 있는 문제


### 트랜잭션 스케줄
- 직렬 스케줄 : 트랜잭션을 순차 실행 -> 해당 트랜잭션 완료 되어야 다른 트랜잭션 실행
- 비직렬 스케줄 : 트랜잭션을 병렬 실행 -> 서로 영향을 줄 가능성이 있음
- 직렬 가능 스케줄 : 서로 영향이 없는 직렬 스케줄을 비직렬적으로 수행 
- 락을 이용하여 동일 데이터 항목에 대해 병행 접근 못하게 제어함
	- 읽기 작업 시 : 공유락
	- 쓰기 작업 시 : 배타락 


### 데드락(Deadlock)
- 두 개 이상의 트랜잭션이 각각 자신의 데이터에 대해 락을 획득하고 상대방 데이터에 대하여 락을 요청하면 무한 대기에 빠질 수 있는 현상 (= 교착상태)
- 일반적으로 DB에서 데드락이 발생하면 T1,T2 중 하나를 강제 중지하여 중지된 트랜잭션 데이터를 돌려놓음


### 트랜잭션 고립 수준

💡**격리 수준에 따른 문제점들**
[ Dirty Read ]
- 읽기 작업을 하는 T1이 쓰기 작업을 하는 T2가 작업한 중간 데이터를 읽어 발생하는 문제
- T2가 Rollback 하는 경우 잘못된 결과를 도출할 수 있음

[ Non-Repeatable Read ]
- T1이 데이터 읽고, T2가 데이터 쓰고, T1이 다시 한 번 데이터 읽으면 생기는 문제 (update)
- T1이 읽기 작업 다시 반복하면, 바로 이전 결과와 다른 결과가 나오는 현상

[ Phantom Read ]
- T1이 데이터 읽고, T2가 데이터 쓰고, T1이 다시 한 번 읽으면 생기는 문제 (Insert)
- T1이 읽기 작업 반복 시, 이전에 없던 데이터(유령 데이터)가 나타나는 현상


💡**격리 수준**
[ READ UNCOMMITTED ]
- 고립 수준 Level 0
- 커밋 되지 않은 데이터 변경 내용을 다른 트랜잭션이 조회하는 것을 허용함
- Dirty Read & Non-Repeatable Read & Phantom Read 발생 가능

[ READ COMMITTED ]
- 고립 수준 Level 1
- 커밋 완료된 변경사항만 다른 트랜잭션에서 조회할 수 있도록 허용함
- 데이터 변경되었으나, 아직 커밋되지 않은 상태면 다른 트랜잭션은 해당 데이터에 접근 시 UNDO 로그를 참고하여 이전의 데이터 읽음
- 팬텀 리드, 반복 불가능한 조회 발생

[ REPEATABLE READ ]
- 특정 행 조회 시, 항상 같은 데이터 응답하는 것을 보장하는 격리 수준
- 행이 추가되는 것(Insert)은 막지 않기 때문에 Phantom Read 발생 가능

[ SERIALIZABLE ]
- 가장 엄격한 고립 수준
- 다른 트랜잭션의 접근을 막기 위해 모든 행을 잠궈버림
- 성능은 가장 떨어짐


### 회복

[ 장애의 유형 ]
- 트랜잭션 장애 : 트랜잭션 실행 시 논리적인 오류로 발생할 수 있는 에러 상황 (0으로 나누기, 오버플로우 등)
- 시스템 장애 : 메모리에 저장되어 있는 정보 손실 같은 상황으로 인해 발생하는 에러 상황
- 미디어 장애 : 디스크 자체의 손상으로 발생할 수 있는 에러 상황

[ 회복 ]
- 데이터베이스를 장애가 발생했던 이전의 상태로 복구하여 일관된 데이터베이스 상태를 만드는 것
- 회복을 위한 데이터 복사본 만드는 방법에는 덤프(Dump)와 로그(Log)를 이용하는 방법 2가지가 존재함
	- 덤프 : 일정 주기로 원본 DB 내용을 다른 저장장치에 복사하는 것
	- 로그 : 변경 연산이 발생할 때마다 로그파일을 작성하여 기록, 회복 시 사용하여 복원


[ 로그 파일을 이용한 회복 ]
- DBMS는 트랜잭션 종료 or 중단 여부 판단함
- 종료된 경우 REDO(재실행)을 진행함 (종료 확정을 위해)
	- REDO는 장애 발생 이후 시스템 재가동 시, 로그 파일에 트랜잭션의 시작과 종료가 있는 경우 로그를 보면서 트랜잭션이 변경한 내용을 다시 기록하는 과정 
- 중단된 경우 UNDO(취소)를 진행함 (없던일로 되돌리기 위해)
	- UNDO는 장애 발생 이후 시스템 재가동 시, 로그 파일에 트랜잭션의 시작과 종료가 없는 경우 완료하지 못했지만 버퍼의 변경 내용이 데이터베이스에 기록되어 있을 가능성이 있기 때문에 로그를 보면서 트랜잭션이 변경한 내용을 원상복구시키는 과정
	- UNDO는 시스템 장애시 다 날아가기 때문에, REDO로 복구해서 UNDO로 COMMIT 되지 않은 데이터 모두 ROLLBACK 하여 복구함



< 참고 자료 >
https://mangkyu.tistory.com/30
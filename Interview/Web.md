
## REST API

[ 개념 ]
- REST를 기반으로 몇 가지의 규칙이 적용된 API를 의미함
- REST란 Resource를 이름으로 구분하여 해당 Resource의 상태를 주고받는 모든 것을 의미함
- HTTP URI를 통해 Resource를 명시하고 HTTP Method를 통해 Resource에 대한 동작 수행
- 즉, REST는 자원 기반의 구조(ROA) 설계의 중심에 Resource가 있고, HTTP Method를 통해 Resource를 처리하도록 설계된 아키텍처이다.


[ 장점 ]
- HTTP 표준 프로토콜을 따르는 모든 플랫폼에서 사용 가능
- 의도 파악이 쉽다


[ 단점 ]
- HTTP Method 형태가 제한적이다
- HTTP에 의존적이다.


[ 규칙 ]
- 동사보다는 명사, 대문자보다는 소문자 사용
- 마지막에 슬래시 포함 X
- 언더바 대신 하이픈 사용
- 행위를 포함하지 않도록 작성


→ 이런 REST API의 설계 규칙을 다 지키고 이를 제공하는 웹 서비스를 비로소 RESTFul API라고 할 수 있음


> RESTFul API를 작성하는 이유는 ?
> : 과거에는 Clinet 프로그램 대상이 PC로 한정되어 있었으나 스마트 기기들(스마트폰, 태블릿)이 등장하면서 Client 프로그램이 다양화 되었고 그에 맞는 Server를 만드는 것은 비효율적이기 때문에 JSON, XML 같은 Client에서 바로 객체로 치환 가능한 형태의 데이터 통신을 지향하게 되면서 Server/Client 역할을 분리함



## Web Server와 WAS

[ 웹서버]
- 정적 페이지는 바뀌지 않는 페이지로 항상 동일한 페이지를 반환함
- 클라이언트가 요청 시 웹 서버는 해당 요청을 받아 정적 컨텐츠를 제공한다

[ WAS ]
- 웹서버 + 웹 컨테이너가 합쳐진 형태
- DB 조회나, 다양한 로직 처리가 필요한 동적 컨텐츠를 제공함 (= Tomcat)

[ 효율적인 설계 ]
- 웹서버를 WAS 앞에 두어 효율적인 분산처리
- ex) 게시판 글 작성, 댓글 등은 WAS에서 처리 (동적) / 게시글 내용 조회, 이미지는 웹서버 처리



## CSR , SSR 

[ CSR ]
- Client-Side Rendering의 약어로 렌더링이 클라이언트 측에서 일어남
- 서버가 요청을 받아 클라이언트에 HTML, JS 파일을 보내고 클라이언트는 렌더링 진행
- 브라우저가 HTML, JS 다운 받는 동안 화면엔 아무것도 안보임
- 장점
	- 새로고침 발생 하지 않아, 사용자 경험에 도움
	- 초기 로딩 이후 빠른 렌더링 가능
- 단점
	- 초기 로딩이 비교적 느림


[ SSR ]
- Server-Side Rendering의 약어로 렌더링으 서버측에서 일어남
- 서버가 렌더링 된 파일을 보내면 브라우저가 받아 화면에 띄우고 JS 파일 다운 (화면에 보임)
- 장점 
	- 첫 페이지 로딩 속도 빠름
	- 검색 엔진 최적화 가능 (이미 서버쪽에서 만들어진 html을 크롤링 할 수 있기 때문에)
- 단점
	- 초기 로딩 이후 페이지 이동시 CSR에 비해 느림
	- 서버 과부하
	- 새로 고침으로 인한 깜빡임 이슈



## CSRF & XSS

[ CSRF ]
- 사이트 간 요청 위조
- 사용자가 의지와 무관하게 침입자가 의도한 행위를 서버에 요청하게 만드는 공격 (서버가 공격 대상)
- 계정 탈취, 결제 요청 등
- 해결 방법
	- Referrer 검증 : 방문 시 남는 흔적같은 것으로 동일 도메인이 아니면 차단
	- CSRF 토큰 생성 : 난수 생성하여 세션에 저장하고 요청마다 난수 값 포함시켜 전송


[ XSS ]
- 웹 사이트에 스크립트를 넣어 공격하는 기법 (클라이언트가 공격 대상)
- 의도치 않은 행동을 수행하거나, 쿠키 및 세션 토큰 등의 민감정보 탈취
- 해결책
	- 민감 정보를 서버에 저장하고 암호화
	- HttpOnly 속성을 통해 쿠키 접근 제어



## MOM, Message Queue, Messsage Broker

[ MOM ]
- Message-Oriented Middleware 
- 서로 다른 애플리케이션 간 데이터 교환을 위해 쉽게 해주는 중간 계층의 소프트웨어


[ Message Queue ]
- 메시지를 일시적으로 저장하는 큐
- 메시지는 큐에 차례대로 쌓이며 소비자가 이를 처리할 수 있음
- 단순히 메시지 저장 및 전달에 주로 쓰임 (ex. 이메일 큐, 로그 큐 등)

[ Message Broker ]
- 메시지를 송신자로부터 받아 수신자에게 전달하는 중간 역할을 하는 소프트웨어 
- 다수의 프로듀서와 컨슈머 간 메시지 교환, 실시간 데이터 스트리밍 등에서 사용됨


## AMQP 란 ?
- Advanced Message Queuing Protocol
- MQ 기반의 프로토콜
- 서로 다른 시스템들 간 최대한 효율적인 방법으로 메세지를 교환하기 위해 탄생하였다.
- 메세지 관리, 큐잉, 라우팅, 신뢰성, 보안 등에 대해 정의하고 있다.
- Exchange, Queue, Binding의 개념이 존재함 (Exchange가 Binding을 통해 Queue 메세지 저장)

## MQ(Message Queue) 쓰는 이유

- 비동기 처리
	- 프로듀서와 컨슈머가 동시에 동작할 필요 없이 독립적으로 작업 수행이 가능함
	- 이를 통해 응답성과, 확장성이 향상됨
- 분산 아키텍처 
	- 서로 다른 시스템 간 메시지를 전달하여 느슨한 결합을 구현할 수 있음
- 로드 밸런싱
	- 메시지 큐를 사용하면 작업을 여러 개의 작업자에게 분산시킬 수 있어 부하 분산이 가능함
	- 시스템 처리 능력 향상
- 버퍼링 기능 
	- 메시지를 처리하는 속도보다 메시지가 빨리 도착해도 큐에 저장해둘 수 있음


## Message Broker 쓰는 이유

- 메시지 라우팅
	- 메시지를 목적지로 효율적으로 라우팅 할 수 있음
- 메시지 보안
	- 메시지 브로커는 인증, 암호화 등의 보안 기능을 제공하여 안전한 메시징을 지원함
- 로드 밸런싱
	- 여러 컨슈머에게 메시지 분산하여 부하를 줄임



## Message Broker / Event Broker

[ Message Broker ]
- 메시지가 생성되면 이를 큐에 저장하고 순서대로 소비함
- 브로커와 소비자 간 결합도가 강하여 수평 확장이 어렵다
- 생성된 메시지 순서대로 소비하고, 큐에서 삭제하기 때문에 메시지를 다시 사용할 수 없다
- 주로 메시지 전달을 중개하는것이 중점적


[ Event Broker ]
- 메시지 발행 시 이를 이벤트로 기록해서 관리함
- 주로 이벤트 게시와 구독을 관리하는 것이 중점적
- 대용량 이벤트 데이터를 실시간으로 처리하고 이벤트 영구 저장으로 추후 다시 사용할 수 있음 

즉, 메시지 브로커는 메시지의 순서를 보장하고, 장애 발생 시 메시지의 손실을 방지하는데 중점을 두는 반면에 이벤트 브로커는 대용량 이벤트를 실시간으로 처리하고 이벤트 데이터를 영구적으로 저장하는데 중점을 둔다.



## 롤링, 블루/그린, 카나리 배포

[ 롤링 ]
- 기존에 실행 중인 인스턴스를 하나씩 새 버전으로 교체
- 인스턴스 하나씩 내리고 새 버전으로 교체한 후 다시 올리는 과정 반복
- 서비스 중단 시간 최소화 , 배포 시간이 길어질 수 있음
- 배포 주기가 빈번하고, 단순한 아키텍처 시스템이었기에 선택함

[ 블루/그린 ]
- 기존 시스템(블루)과 동일한 새로운 환경(그린)을 구축
- 새로운 환경에서 배포 진행 후 테스트 수행
- 테스트 후 라우터를 통해 트래픽을 새 환경으로 전환
- 초기 구축 비용이 높지만, 빠르고 안전한 배포 가능

[ 카나리 ]
- 새 버전의 배포를 제한된 범위에서 먼저 수행하고 안정성 확인
- 일부 실제 트래픽을 새 버전으로 라우팅 하여 테스트
- 문제가 없으면 점진적으로 트래픽 비율을 늘려 전체 시스템으로 배포
- 위험을 최소화 하면서 새 버전의 안전성 검증 가능 
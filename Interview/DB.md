## 실행 순서

FROM → ON → JOIN → WHERE → GROUP BY → HAVING → SELECT → DISTINCT → ORDER BY 
→ LIMIT



## 트리거(Trigger)란 ?

- INSERT, DELETE, UPDATE 같은 DML 문이 수행되었을 때, DB에서 자동으로 동작하도록 작성된 것
- 사용자가 직접 호출하는 것이 아닌, DB에서 자동적으로 호출



## 인덱스(Index)란 ?

[ 개념 ]
- FTS(Full Table Scan)과는 달리 인덱스를 검색하여 해당 자료의 테이블을 엑세스 하는 방법
- 추가적인 쓰기 작업과 저장 공간을 활용하여 DB 검색 속도를 향상시키기 위한 자료구조
- Table 생성 시 3개의 파일이 생성되는데 그 중 하나가 인덱스 관련 정보 파일 (MYI)


[ 장점 ]
- WHERE 절의 효율성 : 기존 FTS → 인덱스 스캔을 통한 빠른 검색
- ORDER BY 절의 효율성 : 정렬 과정을 피할 수 있음 (항상 정렬되어 있기 때문에)


[ 단점 ]
- Index 생성 시 → 추가적인 쓰기 작업 + 저장 공간 필요
- INSERT, UPDATE, DELETE를 통해 데이터 추가 및 변경 일어나면 → 재정렬 해야함
	- UPDATE는 인덱스를 DELETE 하고 새로운 INSERT 수행 → 2배 작업 소요
	- DELETE는 실제 DELETE 처리 하지 않고, 사용 안됨 표시만 함


[ 사용하면 좋은 경우 ]
- WHERE 절 & ORDER BY 절 & JOIN 절에 자주 쓰이는 컬럼
- 중복되는 데이터가 최소한인 컬럼 (분포도가 좋은)


[ 인덱스 구조 ]
- 해시테이블 안쓰는 이유는 해시는 등호(=)에 특화되어 있으나, 값이 1이라도 달라지면 완전히 다른 해시값을 생성하므로 부등호(>,<) 연산이 자주 사용되는 DB 검색에 적합 X
- B-Tree가 왜 선택되었는가 ?
	- 항상 정렬된 상태로 특정 값보다 크고 작은 부등호 연산에 적합
	- 탐색 뿐 아니라 저장, 수정, 삭제도 항상 O(logN)의 시간 복잡도를 가짐
	- 해시는 삽입, 삭제, 수정 등에서 최악의 경우 시간 복잡도가 O(n)임


[ Covering Index ] 
- 조회하려는 Attributes를 인덱스가 모두 cover 할 때, 즉 모두 가지고 있을 때 Covering Index라고 함



## 정규화 

[ 개념 ]
- 하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정


[ 정규형 ]
- 제 1정규형 
	- 테이블의 컬럼이 원자 값 (= 하나의 값)을 갖도록 분해
- 제 2정규형 
	- 제 1정규형 만족, 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해
	- 완전 함수 종속은 기본키의 부분집합이 다른 값을 결정하지 않는 것을 의미
- 제 3정규형 
	- 제 2정규형 만족, 이행적 함수 종속을 없애도록 분해
	- 이행적 종속은 A → B , B → C가 성립할 때 A → C가 성립되는 것을 의미함
- BCNF 정규형 
	- 제 3정규형을 만족, 함수 종속성 X → Y가 성립할 때 모든 결정자 X가 후보키가 되도록 분해


[ 장점 ]
- DB 변경 시 이상현상이 발생하는 문제점 해결 가능
- DB 구조 확장 시, 정규화 된 데이터베이스는 그 구조를 변경하지 않아도 되거나 일부만 변경해도 됨


[ 단점 ]
- 릴레이션 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아짐 → 질의 응답 시간 느려짐


[ 역정규화를 하는 이유 ]
- 정규화를 거치면 릴레이션 간 연산이 많아질 수 있는데 이로 인한 성능 저하 우려가 존재함
- 읽기 작업이 많이 필요한 DB의 전반적인 성능 향상을 위해 역정규화 진행



## 이상(Anomaly) 현상

[ 개념 ]
- 테이블을 잘못 설계하여 데이터 삽입, 삭제, 수정시 생기는 논리적 오류

[ 이상의 종류 ]
- 삽입 이상 : 자료 삽입 시 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 현상
- 갱신 이상 : 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상
- 삭제 이상 : 어떤 정보를 삭제하면, 의도하지 않은 다른 정보까지 삭제되어버리는 현상

[ 해결 방법 ]
- 정규화를 진행하여 릴레이션의 의미를 명확히 하여 해결할 수 있음



## SQL Injection 이란 ?

[ 개념 ]
- 공격자가 악의적인 의도를 갖는 SQL 구문을 삽입하여 DB를 비정상적으로 조작하는 공격 기법


[ 공격 방법 ]
- 인증 우회 : 로그인과 같은 입력 시 동시에 다른 쿼리문을 함께 입력하여 문제를 발생하게 함
- 에러 기반 : DB가 에러 메시지 반환 시, 그 메세지를 통해 정보 추출하는 방법


[ 해결 방법 ]
- Input 값 검증 : 입력 값 받을 때, 특수 문자 여부 검사하기
- SQL 서버 오류 발생 시 View를 활용하여 원본 DB에 대한 접근을 높여 에러를 볼 수 없도록 하는 방법



## RDBMS와 NoSQL 차이

[ RDBMS ] 
- 모든 데이터를 2차원 테이블 형태로 표현
- 장점
	- 스키마에 맞춰 데이터를 관리하기 때문에 데이터 정합성 보장
- 단점
	- 시스템 커질수록 쿼리 복잡 , 성능 저하
	- Scale-out이 어렵고 Scale-up만 가능함 (데이터가 여러 테이블로 분리되어 저장되어 있기 때문에)
	- 스키마에 맞춰 데이터를 관리해야 하기 때문에 보다 엄격하고 제약이 많음
- 사용처
	- 데이터 구조 명확, 변경될 여지가 없고 스키마가 중요한 경우 사용


[ NoSQL ]
- 데이터 간 관게 정의를 하지 않고, 스키마가 없어 좀 더 자유롭게 데이터 관리 가능 (컬렉션 형태로 관리함)
- 장점
	- 스키마 없이 Key-Value 형태로 관리하기 때문에 자유롭게 관리가 가능함
	- 데이터 분산이 용이하여 Scale-Up 뿐만 아니라, Scale-Out도 가능함
- 단점
	- 데이터 중복 발생 가능 → 중복되면 수정 시 모든 컬렉션에서 수정을 수행해야함
	- 스키마가 존재하지 않아서, 명확한 데이터 구조를 보장하지 못함
- 사용처
	- 정확한 데이터 구조를 알 수 없고, 데이터가 변경/확장될 수 있는 경우
	- Update가 많이 이루어지지 않는 시스템



## 트랜잭션(Transaction)

[ 개념 ]
- DBMS에서 데이터를 다루는 작업의 단위임
- 즉, 작업을 모두 처리하거나 처리하지 못한 경우 이전 상태로 복원하여 작업의 일부만 적용되지 않게 만들어줌
- COMMIT은 트랜잭션 수행이 완료됨을 알리는 연산임
- ROLLBACK은 트랜잭션이 행한 모든 연산을 되돌리는 연산임

[ 특징 ]
- 원자성 : 모두 수행 or 전부 수행되지 않아야 함
- 일관성 : 트랜잭션 수행 전이나 후, DB는 일관된 상태를 유지해야함
- 독립성 : 다른 트랜잭션 연산에 끼어들 수 없음 
- 지속성 : 트랜잭션이 완료되면 DB에 영구히 반영되어야 함

[ 고립 수준 ]
- Read Uncommitted : 커밋되지 않은 데이터 읽음
	- Dirty Read, Non-Repeatable Read, Phantom Read 발생 가능
- Read Committed : 커밋된 데이터 읽음
	- Non-Repeatable Read, Phantom Read 발생 가능 → update 되는 행에 대해서 발생
- Repeatable Read : 특정 행 조회 시, 항상 같은 데이터 응답을 보장함
	- Phantom Read 발생 가능 → 행 추가는 막지 않기 때문 
- Seriaizable : 가장 엄격하고 모든 트랜잭션 수행 시 락을 걸기 때문에 성능은 떨어지지만 제일 강력함



## DB 락

[ 개념 ]
- 트랜잭션 처리의 순차성을 보장하기 위한 방법

[ 종류 ]
- 공유락(LS, Shared Lock) : 트랜잭션 읽기 할 때 사용 (공유락 끼리는 동시 접근 가능)
- 베타락(LX, Exclusive Lock) : 트랜잭션 쓰기 할 때 사용(끝나기 전 어떠한 접근도 허용 X)



## DB 튜닝

[ 단계별 튜닝 ]
- 설계 튜닝
	- 반정규화 등 
- DBMS 튜닝
	- 성능 고려하여 메모리나 블록 크기 지정 
	- Buffer 크기, Cache 크기 
- SQL 튜닝
	- JOIN, Indexing



## Join 이란 ?

[ 개념 ]
- 두 개 이상의 테이블을 연결하여 데이터를 검색하는 방법
- 연결하려면 적어도 하나의 컬럼을 공유하므로 이를 활용해 검색에 활용함

[ 종류 ]
- INNER JOIN : 교집합 (테이블 간 중복된 값 )
- OUTER JOIN 
	- LEFT : 왼쪽에 있는 테이블 결과 모두 가져온 후, 오른쪽 테이블 데이터 매칭 (없으면 NULL로 채움)
	- RIGHT: 오른쪽에 있는 테이블 결과 모두 가져온 후, 왼쪽 테이블 데이터 매칭 (없으면 NULL로 채움)
- FULL OUTER JOIN : 합집합, 두 테이블의 모든 데이터 가져옴
- CROSS JOIN : 모든 경우의 수를 전부 가져오는 JOIN 방식
- SELF JOIN : 자기 자신과 조인하는 것
	- 테이블 내의 데이터가 계층적이거나, 자신을 참조해 결과를 보여줘야 하는 경우



## DELETE, TRUNCATE, DROP 차이점

[ DELETE ]
- 데이터를 지우지만 테이블 용량은 줄어들지 않음
- 원하는 데이터만 골라 지울 수 있음
- 삭제 후 되돌릴 수 있음

[ TRUNCATE ]
- 전체 데이터 한 번에 삭제, 테이블 용량 줄어들고 인덱스도 삭제됨
- 테이블은 삭제할 수 없음
- 삭제 후 되돌릴 수 없음

[ DROP ]
- 테이블 자체를 완전히 삭제하는 방식 (인덱스, 공간 모두)
- 삭제 후 되돌릴 수 없음



## 데이터베이스 클러스터링 & 리플리케이션

[ 클러스터링 ]
- 동일한 데이터베이스를 여러 대의 서버가 관리하도록 구축하는 것 (동기 방식)
- 수평적인 구조
- 장점
	- 1개의 DB 서버가 죽어도 다른 DB가 살아 있어 시스템을 장애없이 운영 가능 
	- 기존에 하나의 DB 서버에 몰리던 부하를 분산시킬 수 있음 (로드밸런싱)
- 단점
	- 저장소 하나를 공유하여 병목현상 발생 가능 (전체 시스템 성능, 용량이 하나로 인해 제한 받는 현상)
	- active-stand by 방식으로 해결 가능하나, 로드밸런싱의 효과가 줄어듬


[ 리플리케이션 ]
- 여러 개의 DB를 권한에 따라 Master, Slave로 수직적인 구조로 구축하는 것 (비동기 방식)
- 장점
	- DB 요청의 많은 부분을 읽기 작업이 차지하기 때문에 성능 향상 기대
	- Master, Slave 각기 다른 명령 수행으로 부하 분산
- 단점
	- 노드들 간 데이터 동기화가 보장되지 않아 일관성 있는 데이터를 얻지 못할수도 있음
	- Master DB가 다운되면 복구 및 대처가 까다로움



## 파티셔닝 vs 샤딩

데이터베이스의 볼륨이 커질수록 읽기/쓰기 성능 저하로 적절히 분할이 필요한데, 분할 방법으로는 크게 파티셔닝과 샤딩으로 구분할 수 있음

[ Partitioning ]
- 매우 큰 테이블을 여러 개의 테이블로 분할하는 작업
- 물리적으로 여러 테이블로 분산되어 저장되지만 사용자는 하나의 테이블에 접근하는 것처럼 사용 가능
- 종류
	- List Partitioning : 데이터 값이 특정 목록에 포함되는 경우 분리 (ex. 지역별)
	- Range Partitioning : 범위 분할
	- Hash Partitioning : 해시 함수로 분할
	- Compose Partitioning : 1 ~ 3번 중 2개 이상 사용하는 방식


[ Sharding ]
- 동일 스키마를 가지고 있는 여러 대의 데이터베이스 서버들에 데이터를 작은 단위로 분산 저장하는 기법
- 이 '작은 단위'를 샤드라고 함
- 파티셔닝은 모든 데이터를 동일 서버에 저장하지만, 샤딩은 서로 다른 서버에 분산한다는 차이가 있음
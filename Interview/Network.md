
## HTTP 프로토콜 

[ 개념 ]
- Hyper Text Transfer Protocol 이란 데이터를 주고 받기 위한 프로토콜로 서버/클라이언트 모델임
- 상태 정보를 저장하지 않는 stateless 구조와 응답 후 연결을 끊는 connectionless의 특징을 가짐
- 장점
	- 통신 간 연결 상태, 상태 정보를 관리할 필요가 없어 간단함
	- 각각 HTTP 요청에 독립적으로 응답만 보내주면 됨
- 단점
	- 이전 통신의 정보를 모르기 때문에 매번 인증해야 함
	- 이를 해결하기 위해 쿠키 or 세션을 사용해 처리함


## HTTP와 HTTPS의 차이점

- HTTP는 평문 데이터 전송 프로토콜로 중요 정보를 주고 받을 때 제 3자에 의해 조회될 가능성이 존재한다.
- 이러한 문제 해결을 위해 HTTP에 암호화가 추가된 프로토콜이 HTTPS임 
- HTTPS는 SSL의 껍질을 덮어쓴 HTTP임 (SSL : 정보를 보호하기 위해 개발한 통신 규약)
- HTTP는 TCP와 직접 통신, HTTPS는 HTTP는 SSL과 통신 SSL은 TCP와 통신 → 안전


## 쿠키 & 세션 & 캐시

[ 쿠키 ]
- 클라이언트 컴퓨터에 저장하는 작은 기록정보 파일
- 로컬에 저장되어 스니핑 당할 위험이 존재함
- 만료 시점은 저장 시 설정이 가능함 (브라우저 종료되도 만료 시점 안되면 삭제되지 않음)
- 세션보다 속도가 빠르며 보안은 세션에 비해 떨어짐
- ex) 자동 로그인 유지, 팝업 보지 않기 등

[ 세션 ]
- 서버측에 저장되며 일정 시간 동안 같은 사용자로부터 들어오는 요청을 하나의 상태로 보고 유지하는 기술
- 브라우저 종료 시 삭제됨
- 쿠키보다 속도가 느리며, 보안은 쿠키에 비해 뛰어남
- 로그인 정보 유지

[ 캐시 ]
- 파일들의 임시 저장소
- 같은 웹 페이지 접속 시 사용자 PC에서 로드하므로 서버를 거치지 않아도 됨
- 캐시 히트 : CPU가 참조하려는 메모리가 캐시에 존재하고 있는 경우
- 캐시 미스 : 캐시 히트와 반대로, 메모리에 캐시가 존재하지 않는 경우

→ 캐시는 웹 페이지 요소를 저장하기 위한 임시 저장소, 쿠키/세션은 정보 저장을 위해 사용함



## TCP/IP (흐름제어/혼잡제어)

[ 흐름 제어 ]
- 송신측과 수신측 사이 데이터 처리 속도 차이를 해결하기 위한 기법
- 송신측이 수신측이 처리하는 것보다 많이 보내면 손실 가능성이 있어 제어해줘야 함
- 정지 - 대기 방식
- 슬라이딩 윈도우 방식 (수신측에서 설정한 윈도우 크기만큼 전송하여 동적 조절)

[ 혼잡 제어 ]
- 송신측에서 보내는 데이터의 전송 속도를 제어
- 슬로우 스타트 방식(패킷을 하나씩 보내고, ACK 패킷을 받으면 그에 따라 window size를 1씩 늘리는 방식)



## TCP & UDP
| 프로토콜 종류  | TCP        | UDP                  |
| -------- | ---------- | -------------------- |
| 연결 방식    | 연결형 서비스    | 비연결형 서비스             |
| 패킷 교환 방식 | 가상 회선 방식   | 데이터그램 방식             |
| 전송 순서    | 전송 순서 보장   | 전송 순서가 바뀔 수 있음       |
| 수신 여부 확인 | 수신 여부를 확인함 | 수신 여부를 확인하지 않음       |
| 통신 방식    | 1:1 통신     | 1:1 OR 1:N OR N:N 통신 |
| 신뢰성      | 높다.        | 낮다.                  |
| 속도       | 느리다.       | 빠르다.                 |
| 예시       | 이메일 전송     | 실시간 스트리밍             |
- 가상 회선 방식 
	- 모든 패킷의 경로 일정하기 유지함 (전송 이전의 논리적인 통신 경로가 미리 설정됨)
	- 가상 연결 설정을 통해 전송되는 모든 패킷의 경로가 동일
	- 도착 순서 일정함

 - 데이터그램 방식
	- 서로 다른 경로 이용
	- 패킷을 독립적으로 전송
	- 도착 순서 일정하지 않음



## 대칭키 & 공개키(=비대칭키)

[ 개념 ]
- 대칭키와 공개키 방식은 양방향 암호화 방식임

[ 대칭키 ]
- 암호화와 복호화에 같은 키를 쓰는 알고리즘
- 누군가 암호키를 가로채면 정보 유출될 가능성이 존재함 → 이를 보완한게 공개키

[ 비대칭키 ]
- 암호화와 복호화에 서로 다른 키를 쓰는 알고리즘
- 타인에게 노출되어선 안되는 개인키와 공개적으로 개방되어 있는 공개키를 쌍으로 이룸
- RSA가 있음

[ RSA의 단점 및 해결하기 ]
- 비대칭키를 통해 완벽한 보안 유지가 되어 좋다고 생각이 들 수 있다.
- 하지만 단점이 존재하는데 많은 데이터를 암호화 하려면, 처리할 수 있는 숫자 범위를 넘어버릴 수 있음
- 상대적으로 대칭키는 속도가 굉장히 빠름
- 결국 대칭키를 주고 받을 때 비대칭키 암호화 방식을 통해 키를 교환하고 나면 이후에는 대칭키 암호화로 통신



## www.naver.com 접속 시 생기는 과정 (웹 동작 방식)
- 사용자가 브라우저에 URL 입력
- DNS 서버에 도메인 네임으로 서버 진짜 주소 찾음
- IP 주소로 웹 서버에 TCP 3 handshake 연결 수립
- 클라이언트는 웹 서버로 HTTP 요청 메세지 보냄
- 웹 서버는 HTTP 응답 메세지 보냄
- 웹 브라우저에 의해 출력 



### 3 way Handshake & 4 way Handshake
- 3 way handshake (연결)
    - 클라 → 서버로 SYN(= Sequence Number)패킷 전송
    - 서버 SYN 받고 → 클라로 ACK & SYN 패킷 전송
    - 클라는 ACK & SYN 받고 → 서버로 ACK 보냄
- 4 way handshake (종료)
    - 클라 → 서버로 FIN 플래그 전송
    - 서버 FIN 받고 → 클라로 ACK 전송 (CLOSE_WAIT 상태로 전환)
    - 데이터 모두 보내면 → 클라로 FIN 플래그 전송
    - 클라는 FIN을 받고 → 서버로 ACK (TIME_WAIT 상태로 전환)
    - 서버는 ACK 받고 소켓 닫음
    - 클라는 TIME_WAIT 시간 끝나면 닫음



## GET / POST 차이

[ GET ] 
- 데이터 조회 시 보통 사용
- URL에 데이터 노출함
- 데이터가 Header에 위치함
- 캐싱이 가능하고 멱등성 보장

[ POST ]
- 데이터 등록 시 보통 사용
- URL에 데이터 노출안함
- 데이터가 Body에 위치함
- 캐싱이 불가능하고 멱등성을 보장하지 않음



## 세션 기반 인증 & 토큰 기반 인증

[ 세션 기반 ]
- 클라이언트 상태 정보 저장하므로 stateful
- 서버 과부하 가능성이 존재
- 해커가 훔친 쿠리를 이용해 요청을 보내도 알 수 없음 (세션 하이재킹)
- 세션 관리 시 사용되는 쿠키는 단일 도메인 적용 → CORS 문제 생김 (여러 도메인)

[ 토큰 기반 ]
- 상태 정보를 서버에 저장하지 않기 때문에 Stateless



## 로드 밸런싱 (Load Balancing)
- 둘 이상의 CPU or 저장장치와 같은 자원들에게 작업을 나누는 것
- 트래픽 증가에 따라 성능을 올리는 scale-up 또는 서버 개수를 늘리는 scale-out 방식을 채택
- 여러 서버에 균등하게 트래픽을 분산시켜주는 것이 바로 로드 밸런싱
- 서버 선택 방법
	- 라운드 로빈 (동일 시간 할당 받아 시간 동안만 작업 수행)
	- 연결 개수가 가장 적은 서버 선택
- 이중화를 통해 오류를 대비함



## Blocking / Non-Blocking & Synchronus / Asynchronous
![[Pasted image 20240527185751.png]]
- Blocking
    - 자신의 작업을 진행하다가 다른 주체의 작업 시작되면 → 끝날 때까지 기다렸다 시작
    - 호출된 함수가 제어권을 갖고 호출한 함수에게 바로 돌려주지 않는 상황
- Non-Blocking
    - 다른 주체 작업에 관련없이 자신의 작업을 하는 것을 의미함
    - 호출된 함수가 자신이 할 일을 모두 마치지 않았더라도 바로 제어권을 건내줌
- Sync
    - 작업 실행 시 해당 작업 완료될 때까지 기다림
    - 호출된 함수의 수행 결과 및 종료를 호출한 함수와 함께 신경 씀
- Async
    - 작업 실행되고 완료동안 다른 작업 수행 가능
    - 호출된 함수의 수행 결과 및 종료를 호출된 함수 혼자 쓰고 처리함

→ 정리하자면
- Blocking/Non-Blocking : 제어권을 안넘기는지 / 넘기는지
- Sync / Async : 결과를 돌려줄 때 결과와 순서에 관심이 있는지 / 



## OSI 7계층

> 나누는 이유 
> : 통신이 일어나는 과정 단계별 파악 & 이상 생기는 단계만 수정하기 위함

[ 물리 계층 - 1 ]
- 데이터 전기 신호로 바꾸어 주는 계층

[ 데이터링크 계층 - 2 ]
- 데이터 물리적인 전송과 에러 검출, 흐름제어

[ 네트워크 계층 - 3 ]
- 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층

[ 전송 계층 - 4 ]
- 최종 수신 프로세스로 데이터 전송을 담당하는 계층 (TCP, UDP)

[ 세션 계층 - 5 ]
- 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층

[ 표현 계층 - 6 ]
- 데이터 형식 정의 계층 

[ 응용 계층 - 7 ]
- 사용자에게 서비스 제공, 인터페이스 역할


